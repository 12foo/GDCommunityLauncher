#include <filesystem>
#include "TEXImage.h"
#include "ItemDBR.h"
#include "Log.h"

// List of different variable names that could point to the item bitmap
const std::vector<std::string> bitmapVariables =
{
    "bitmap",
    "artifactBitmap",
    "relicBitmap",
    "noteBitmap",
    "artifactFormulaBitmapName",
};

// List of directories to search for item DBRs
const std::vector<std::string> searchPaths =
{
    "records/items",
    "records/storyelements/signs",      // For some reason Lokarr's set is stored here instead of in records/items
    "records/endlessdungeon/items",
};

void GenerateItemDB(const std::filesystem::path& dataPath, const std::filesystem::path& outPath)
{
    if ((!std::filesystem::is_directory(dataPath)) || (!std::filesystem::is_directory(outPath)))
    {
        // TODO: Throw an exception/log error message here
        return;
    }

    std::vector<ItemDBR> itemDBRs;
    for (uint32_t i = 0; i < searchPaths.size(); ++i)
    {
        std::filesystem::path searchPath = dataPath / searchPaths[i];
        for (auto& entry : std::filesystem::recursive_directory_iterator(searchPath))
        {
            if (entry.is_regular_file() && (entry.path().extension() == ".dbr"))
            {
                try
                {
                    itemDBRs.emplace_back(entry.path().string());
                }
                catch (std::runtime_error& ex)
                {
                    // TODO: Throw an exception/log error message here
                    return;
                }
            }
        }
    }

    if (itemDBRs.empty())
    {
        // TODO: Throw an exception/log error message here
        return;
    }

    std::filesystem::path outFilePath = outPath / "ItemDatabase.cpp";

    FILE* file;
    if (fopen_s(&file, outFilePath.string().c_str(), "w") != 0)
    {
        // TODO: Throw an exception/log error message here
        return;
    }

    fprintf_s(file, "// This file is automatically generated by the GDCL extractor\n");
    fprintf_s(file, "#include \"ItemDatabase.h\"\n\n");
    fprintf_s(file, "const std::map<std::string, ItemDatabase::ItemDBEntry> ItemDatabase::_database = \n{\n");

    //TODO: Also extract the item bitmaps and save them for later use?
    for (uint32_t i = 0; i < itemDBRs.size(); ++i)
    {
        uint32_t width = itemDBRs[i].GetWidth();
        uint32_t height = itemDBRs[i].GetHeight();
        if ((width > 0) && (height > 0))
        {
            fprintf_s(file, "\t{ \"%s\", { %d, %d } },\n", itemDBRs[i].GetRecordPath().c_str(), width/32, height/32);
        }
    }

    fprintf_s(file, "};");

    fclose(file);
}

ItemDBR::ItemDBR(const std::string& filename)
{
    if (!Load(filename))
        throw std::runtime_error(Logger::LogMessage(LOG_LEVEL_ERROR, "The specified file is not a valid item DBR file"));

    const Value* bitmapPath = nullptr;
    for (uint32_t i = 0; i < bitmapVariables.size(); ++i)
    {
        bitmapPath = GetVariable(bitmapVariables[i]);
        if (bitmapPath)
            break;
    }

    if (bitmapPath)
    {
        std::filesystem::path texturePath = std::filesystem::path(GetRootPath()) / bitmapPath->ToString();
        if (std::filesystem::is_regular_file(texturePath))
        {
            TEXImage image(texturePath.string());

            _width = image.GetWidth();
            _height = image.GetHeight();
        }
        else
        {
            Logger::LogMessage(LOG_LEVEL_WARN, "Item DBR refers to bitmap \"%\" which does not exist. Width/height data will not be loaded.", texturePath);
        }
    }
    else
    {
        Logger::LogMessage(LOG_LEVEL_WARN, "Item DBR does not contain bitmap data. Width/height data will not be loaded.");
    }
}